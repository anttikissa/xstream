<!doctype html>
<head>
<title>Cells test</title>
<script src='../dist/xstream.js'></script>
<script>
window.addEventListener('load', function() {

	// Tired of typing console.log everywhere.
	var log = console.log.bind(console);

	// A stream that updates on every DOM event of type 'event' on 'el'.
	function eventStream(el, event) {
		var result = stream();
		el.addEventListener(event, function(e) {
			result.update(e);
		});
		return result;
	}

	// Update DOM element's .value whenever 'stream' updates.
	function assign(stream, el) {
		stream.forEach(function(value) {
			el.value = value;
		});
	}

	// Collection of all cells, indexed by id like 'A1'
	var cells = {};

	// Shorthand for document.createElement.
	function elem(type) {
		return document.createElement(type);
	}

	// Convert a string to an actual value.
	// If it looks like a number, make it a number; 
	// otherwise leave as it is.
	//
	// '' -> 0
	// '1' -> 1
	// 'abc' -> 'abc'
	function convert(str) {
		var number = Number(str);
		if (isNaN(number))
			return str;
		return number;
	}

	// Does it look like the is user typing in a formula?
	// (Formulas start with '='.)
	function looksLikeFormula(s) {
		return s[0] === '=';
	}

	// Create a cell.
	function cell(id) {
		var el = elem('input');
		el.id = id;

		// A hack to create column and row headers
		if (id[0] === ' ' || id[1] === ' ') {
			el.disabled = true;
			el.value = id;
			return el;
		}

		cells[id] = el;

		// 'inputValues' is a a stream of everything that the user types
		// into the <input> element.
		el.inputValues = eventStream(el, 'change').map(function(ev) {
			return ev.target.value;
		}).uniq();

		// If the stream will at some point contain a formula,
		// 'dynamicValues' will be rewired to a stream that reflects its
		// value.
		el.dynamicValues = stream();

		// Stream of input values that do not begin with '='
		var normalInputs = el.inputValues.filter(
			stream.util.not(looksLikeFormula));

		// Stream of input values that begin with '='
		var dynamicInputs = el.inputValues.filter(looksLikeFormula);

		// 'values' is a stream of the actual values of the cell.
		// It either shows the most recent non-formula value that has
		// been typed into the cell, or the most recent dynamic value
		// generated by el.dynamicValues.
		el.values = stream.merge(
			normalInputs.map(convert),
			el.dynamicValues).name(id);

		// On input values like '=<formula>':
		// - turn <formula> into a function,
		// - use stream.combine() to make a stream that uses the function to 
		//   combine the value streams the cells it refers to,
		// - rewire el.dynamicValues with the aforementioned stream,
		// - and save the formula in el.formula.
		dynamicInputs.forEach(function(value) {
			var formula = value.substr(1);
			var refs = formula.match(/[A-Z][0-9]+/g) || [];
			var f = new Function(refs.join(','), "return " + formula + ";");
			var combineArgs = refs.map(function(ref) {
				return cells[ref].values;
			}).concat(f);
			var dynamicValues = stream.combine.apply(
				undefined, combineArgs).pull();
			try {
				el.dynamicValues.rewire(dynamicValues);
			} catch (e) {
				console.log('!!! ERREUR', e);
			}
			el.formula = formula;
		});

		normalInputs.forEach(function() {
			// Neutralize the dynamic input stream
			el.dynamicValues.rewire(stream());
			delete el.formula;
		});

		// Whenever an element's value changes, show it in the UI as
		// well.  Won't cause an infinite loop because setting a
		// DOM element's .value programmatically doesn't trigger a
		// change event.
		assign(el.values, el);

		eventStream(el, 'focus').forEach(function() {
			if (el.formula) {
				el.value = '=' + el.formula;
			}
		});

		eventStream(el, 'blur').forEach(function() {
			if (el.values.value !== undefined) {
				el.value = el.values.value;
			}
		});


		// For navigating between cells.
		function nextId(id, rowChange) {
			var match = id.match(/([A-Z]+)([0-9]+)/);
			var row = Number(match[2]) + rowChange;
			return match[1] + row;
		}

		function move(rowChange) {
			var next = nextId(el.id, rowChange)
			if (cells[next]) {
				cells[next].focus();
				cells[next].selectionStart = 0;
			}
		}

		// Map key events to movements
		eventStream(el, 'keydown').forEach(function(event) {
			switch (event.keyCode) {
				case 13: return move(1); // enter -> down
				case 40: return move(1); // down
				case 38: return move(-1); // up
			}
		});

		// All cells start with the value of zero.
		el.value = 0;

		// Bootstrap the value stream with the initial value.
		el.values.update(convert(el.value));

		return el;
	}

	// Shorthand for document.body.appendChild.
	function push(elem) {
		document.body.appendChild(elem);
	}

	// Populate the DOM with cells.
	[' ', 1,2,3,4,5,6,7,8,9,10].forEach(function(row) {
		" ABCDEFGHI\n".split('').forEach(function(column) {
			if (column === '\n')
				push(elem('br'));
			else
				push(cell(column + row));
		});
	});

	// And focus on the first one.
	cells.A1.focus();

	// A small test.
	setTimeout(function() {
		cells.B1.inputValues.update('=A1 + 1');
		cells.C1.inputValues.update('=B1 + 2');
		cells.A1.inputValues.update('123');
	}, 100);
});
</script>
<style>
	input {
		margin: 0;
		width: 100px;
	}

	input:disabled {
		background: #eee;
	}
</style>

